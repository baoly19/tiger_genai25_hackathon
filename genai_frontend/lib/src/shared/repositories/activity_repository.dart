import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/activity_model.dart';
import '../../core/services/supabase_service.dart';

part 'activity_repository.g.dart';

class ActivityRepository {
  final SupabaseClient _client;
  
  ActivityRepository(this._client);
  
  // Create new activity
  Future<ActivityModel> createActivity(ActivityModel activity) async {
    try {
      final response = await _client
          .from('activities')
          .insert(activity.toJson())
          .select()
          .single();
      
      return ActivityModel.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }
  
  // Get user activities with filtering
  Future<List<ActivityModel>> getUserActivities(
    String userId, {
    String? type,
    DateTime? startDate,
    DateTime? endDate,
    int limit = 20,
    int offset = 0,
  }) async {
    try {
      var queryBuilder = _client
          .from(SupabaseService.activitiesTable)
          .select()
          .eq('user_id', userId);
      
      if (type != null) {
        queryBuilder = queryBuilder.eq('type', type);
      }
      
      if (startDate != null) {
        queryBuilder = queryBuilder.gte('action_date', startDate.toIso8601String());
      }
      
      if (endDate != null) {
        queryBuilder = queryBuilder.lte('action_date', endDate.toIso8601String());
      }
      
      // Chain operations directly to avoid type issues
      final response = await queryBuilder
          .order('action_date', ascending: false)
          .limit(limit)
          .range(offset, offset + limit - 1);
      
      return (response as List<dynamic>)
          .map((json) => ActivityModel.fromJson(json as Map<String, dynamic>))
          .toList();
    } catch (e) {
      throw Exception('Failed to get user activities: $e');
    }
  }

  // Get user activity summary
  Future<ActivitySummary> getSummary(String userId) async {
    try {
      final allActivities = await getUserActivities(userId, limit: 1000);
      
      final now = DateTime.now();
      final weekStart = now.subtract(Duration(days: now.weekday - 1));
      final monthStart = DateTime(now.year, now.month, 1);
      
      final thisWeek = allActivities.where((a) => 
          a.actionDate != null && a.actionDate!.isAfter(weekStart)).length;
      
      final thisMonth = allActivities.where((a) => 
          a.actionDate != null && a.actionDate!.isAfter(monthStart)).length;
      
      final bookingsCount = allActivities.where((a) => a.type == 'booking').length;
      final groupsJoined = allActivities.where((a) => a.type == 'group_join').length;
      final eventsAttended = allActivities.where((a) => a.type == 'event_registration').length;
      final courtsReviewed = allActivities.where((a) => a.type == 'court_review').length;
      
      // Get activity type counts
      final activityTypes = <String, int>{};
      for (final activity in allActivities) {
        activityTypes[activity.type] = (activityTypes[activity.type] ?? 0) + 1;
      }
      
      // Get favorite activities (most frequent)
      final favoriteActivities = activityTypes.entries
          .toList()
          ..sort((a, b) => b.value.compareTo(a.value));
      
      // Get recent locations
      final recentLocations = allActivities
          .where((a) => a.location != null)
          .take(10)
          .map((a) => a.location!)
          .toSet()
          .toList();
      
      return ActivitySummary(
        totalActivities: allActivities.length,
        thisWeekActivities: thisWeek,
        thisMonthActivities: thisMonth,
        bookingsCount: bookingsCount,
        groupsJoined: groupsJoined,
        eventsAttended: eventsAttended,
        courtsReviewed: courtsReviewed,
        favoriteActivities: favoriteActivities.map((e) => e.key).take(3).toList(),
        recentLocations: recentLocations,
        lastActivity: allActivities.isNotEmpty ? allActivities.first.actionDate : null,
      );
    } catch (e) {
      throw Exception('Failed to get activity summary: $e');
    }
  }
  
  // Get activities by type
  Future<List<ActivityModel>> getActivitiesByType(
    String userId,
    String type, {
    int limit = 20,
  }) async {
    return getUserActivities(userId, type: type, limit: limit);
  }
  
  // Create booking activity
  Future<ActivityModel> createBookingActivity(
    String userId,
    String courtId,
    String courtName,
    String location,
    DateTime bookingDate,
    String timeSlot,
    double price,
  ) async {
    final activity = ActivityModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      type: 'booking',
      title: 'Court Booked',
      description: 'Booked $courtName for $timeSlot',
      entityId: courtId,
      entityType: 'court',
      entityName: courtName,
      location: location,
      actionDate: bookingDate,
      metadata: {
        'time_slot': timeSlot,
        'price': price,
      },
      createdAt: DateTime.now(),
    );
    
    return createActivity(activity);
  }

  // Create booking cancellation activity
  Future<ActivityModel> createBookingCancellationActivity(
    String userId,
    String courtId,
    String courtName,
    DateTime bookingDate,
    String timeSlot,
  ) async {
    final activity = ActivityModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      type: 'booking_cancellation',
      title: 'Booking Cancelled',
      description: 'Cancelled booking for $courtName at $timeSlot',
      entityId: courtId,
      entityType: 'court',
      entityName: courtName,
      actionDate: DateTime.now(),
      metadata: {
        'original_booking_date': bookingDate.toIso8601String(),
        'time_slot': timeSlot,
      },
      createdAt: DateTime.now(),
    );
    
    return createActivity(activity);
  }
  
  // Create group join activity
  Future<ActivityModel> createGroupJoinActivity(
    String userId,
    String groupId,
    String groupName,
    String sport,
  ) async {
    final activity = ActivityModel(
      id: '',
      userId: userId,
      type: 'group_join',
      title: 'Joined Group',
      description: 'Joined "$groupName" group',
      entityId: groupId,
      entityType: 'group',
      entityName: groupName,
      actionDate: DateTime.now(),
      metadata: {
        'sport': sport,
      },
      createdAt: DateTime.now(),
    );
    
    return createActivity(activity);
  }
  
  // Create event registration activity
  Future<ActivityModel> createEventRegistrationActivity(
    String userId,
    String eventId,
    String eventTitle,
    String location,
    DateTime eventDate,
  ) async {
    final activity = ActivityModel(
      id: '',
      userId: userId,
      type: 'event_registration',
      title: 'Event Registered',
      description: 'Registered for "$eventTitle"',
      entityId: eventId,
      entityType: 'event',
      entityName: eventTitle,
      location: location,
      actionDate: eventDate,
      createdAt: DateTime.now(),
    );
    
    return createActivity(activity);
  }
  
  // Create court review activity
  Future<ActivityModel> createCourtReviewActivity(
    String userId,
    String courtId,
    String courtName,
    String location,
    double rating,
  ) async {
    final activity = ActivityModel(
      id: '',
      userId: userId,
      type: 'court_review',
      title: 'Court Reviewed',
      description: 'Reviewed $courtName (${rating.toStringAsFixed(1)} stars)',
      entityId: courtId,
      entityType: 'court',
      entityName: courtName,
      location: location,
      actionDate: DateTime.now(),
      metadata: {
        'rating': rating,
      },
      createdAt: DateTime.now(),
    );
    
    return createActivity(activity);
  }
  
  // Create achievement activity
  Future<ActivityModel> createAchievementActivity(
    String userId,
    String achievementType,
    String title,
    String description,
  ) async {
    final activity = ActivityModel(
      id: '',
      userId: userId,
      type: 'achievement',
      title: title,
      description: description,
      priority: 'high',
      actionDate: DateTime.now(),
      metadata: {
        'achievement_type': achievementType,
      },
      createdAt: DateTime.now(),
    );
    
    return createActivity(activity);
  }
  
  // Delete activity
  Future<void> deleteActivity(String activityId) async {
    try {
      await _client
          .from('activities')
          .delete()
          .eq('id', activityId);
    } catch (e) {
      rethrow;
    }
  }
  
  // Get activities by date range
  Future<List<ActivityModel>> getActivitiesByDateRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    return getUserActivities(
      userId,
      startDate: startDate,
      endDate: endDate,
      limit: 100,
    );
  }
}

@riverpod
ActivityRepository activityRepository(ActivityRepositoryRef ref) {
  final client = ref.read(supabaseClientProvider);
  return ActivityRepository(client);
} 