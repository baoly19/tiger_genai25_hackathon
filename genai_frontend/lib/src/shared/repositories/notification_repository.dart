import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../models/notification_model.dart';
import '../../core/services/supabase_service.dart';

part 'notification_repository.g.dart';

class NotificationRepository {
  final SupabaseClient _client;
  
  NotificationRepository(this._client);
  
  // Create new notification
  Future<NotificationModel> createNotification(NotificationModel notification) async {
    try {
      final response = await _client
          .from(SupabaseService.notificationsTable)
          .insert(notification.toJson())
          .select()
          .single();
      
      return NotificationModel.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }
  
  // Get user notifications
  Future<List<NotificationModel>> getUserNotifications(
    String userId, {
    bool? isRead,
    String? type,
    int? limit = 50,
    int? offset = 0,
  }) async {
    try {
      var query = _client
          .from(SupabaseService.notificationsTable)
          .select()
          .eq('user_id', userId);
      
      if (isRead != null) {
        query = query.eq('is_read', isRead);
      }
      
      if (type != null) {
        query = query.eq('type', type);
      }
      
      if (limit != null) {
        query = query.limit(limit);
      }
      
      if (offset != null) {
        query = query.range(offset, offset + (limit ?? 50) - 1);
      }
      
      query = query.order('created_at', ascending: false);
      
      final response = await query;
      
      return response.map<NotificationModel>((json) => NotificationModel.fromJson(json)).toList();
    } catch (e) {
      rethrow;
    }
  }
  
  // Get notification by ID
  Future<NotificationModel?> getNotificationById(String notificationId) async {
    try {
      final response = await _client
          .from(SupabaseService.notificationsTable)
          .select()
          .eq('id', notificationId)
          .single();
      
      return NotificationModel.fromJson(response);
    } catch (e) {
      return null;
    }
  }
  
  // Mark notification as read
  Future<NotificationModel> markAsRead(String notificationId) async {
    try {
      final response = await _client
          .from(SupabaseService.notificationsTable)
          .update({
            'is_read': true,
            'read_at': DateTime.now().toIso8601String(),
          })
          .eq('id', notificationId)
          .select()
          .single();
      
      return NotificationModel.fromJson(response);
    } catch (e) {
      rethrow;
    }
  }
  
  // Mark all notifications as read for a user
  Future<void> markAllAsRead(String userId) async {
    try {
      await _client
          .from(SupabaseService.notificationsTable)
          .update({
            'is_read': true,
            'read_at': DateTime.now().toIso8601String(),
          })
          .eq('user_id', userId)
          .eq('is_read', false);
    } catch (e) {
      rethrow;
    }
  }
  
  // Delete notification
  Future<void> deleteNotification(String notificationId) async {
    try {
      await _client
          .from(SupabaseService.notificationsTable)
          .delete()
          .eq('id', notificationId);
    } catch (e) {
      rethrow;
    }
  }
  
  // Delete all notifications for a user
  Future<void> deleteAllNotifications(String userId) async {
    try {
      await _client
          .from(SupabaseService.notificationsTable)
          .delete()
          .eq('user_id', userId);
    } catch (e) {
      rethrow;
    }
  }
  
  // Get unread notification count
  Future<int> getUnreadCount(String userId) async {
    try {
      final response = await _client
          .from(SupabaseService.notificationsTable)
          .select('id', const FetchOptions(count: CountOption.exact))
          .eq('user_id', userId)
          .eq('is_read', false);
      
      return response.length;
    } catch (e) {
      return 0;
    }
  }
  
  // Subscribe to user notifications for real-time updates
  Stream<List<NotificationModel>> subscribeToUserNotifications(String userId) {
    return _client
        .from(SupabaseService.notificationsTable)
        .stream(primaryKey: ['id'])
        .eq('user_id', userId)
        .order('created_at', ascending: false)
        .map((data) => data.map<NotificationModel>((json) => NotificationModel.fromJson(json)).toList());
  }
  
  // Send booking reminder notification
  Future<NotificationModel> sendBookingReminder({
    required String userId,
    required String bookingId,
    required String courtName,
    required DateTime bookingTime,
  }) async {
    final notification = NotificationModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      title: 'Booking Reminder',
      message: 'Your booking at $courtName is starting soon',
      type: 'booking',
      data: {
        'booking_id': bookingId,
        'court_name': courtName,
        'booking_time': bookingTime.toIso8601String(),
      },
      priority: 'high',
      createdAt: DateTime.now(),
    );
    
    return createNotification(notification);
  }
  
  // Send group invite notification
  Future<NotificationModel> sendGroupInviteNotification({
    required String userId,
    required String groupId,
    required String groupName,
    required String inviterName,
  }) async {
    final notification = NotificationModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      title: 'Group Invitation',
      message: '$inviterName invited you to join $groupName',
      type: 'group_invite',
      data: {
        'group_id': groupId,
        'group_name': groupName,
        'inviter_name': inviterName,
      },
      priority: 'medium',
      createdAt: DateTime.now(),
    );
    
    return createNotification(notification);
  }
  
  // Send event update notification
  Future<NotificationModel> sendEventUpdateNotification({
    required String userId,
    required String eventId,
    required String eventTitle,
    required String updateMessage,
  }) async {
    final notification = NotificationModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      title: 'Event Update',
      message: '$eventTitle: $updateMessage',
      type: 'event',
      data: {
        'event_id': eventId,
        'event_title': eventTitle,
      },
      priority: 'medium',
      createdAt: DateTime.now(),
    );
    
    return createNotification(notification);
  }
  
  // Send new message notification
  Future<NotificationModel> sendNewMessageNotification({
    required String userId,
    required String groupId,
    required String groupName,
    required String senderName,
    required String messagePreview,
  }) async {
    final notification = NotificationModel(
      id: '', // Will be generated by Supabase
      userId: userId,
      title: 'New Message',
      message: '$senderName in $groupName: $messagePreview',
      type: 'message',
      data: {
        'group_id': groupId,
        'group_name': groupName,
        'sender_name': senderName,
      },
      priority: 'low',
      createdAt: DateTime.now(),
    );
    
    return createNotification(notification);
  }
  
  // Clean up expired notifications
  Future<void> cleanupExpiredNotifications() async {
    try {
      final now = DateTime.now();
      await _client
          .from(SupabaseService.notificationsTable)
          .delete()
          .lt('expires_at', now.toIso8601String());
    } catch (e) {
      // Handle error silently for this background operation
    }
  }
  
  // Get notifications by type
  Future<List<NotificationModel>> getNotificationsByType(
    String userId,
    String type, {
    int? limit = 20,
  }) async {
    try {
      var query = _client
          .from(SupabaseService.notificationsTable)
          .select()
          .eq('user_id', userId)
          .eq('type', type);
      
      if (limit != null) {
        query = query.limit(limit);
      }
      
      query = query.order('created_at', ascending: false);
      
      final response = await query;
      
      return response.map<NotificationModel>((json) => NotificationModel.fromJson(json)).toList();
    } catch (e) {
      rethrow;
    }
  }
  
  // Bulk create notifications (for system-wide notifications)
  Future<List<NotificationModel>> createBulkNotifications(
    List<NotificationModel> notifications,
  ) async {
    try {
      final response = await _client
          .from(SupabaseService.notificationsTable)
          .insert(notifications.map((n) => n.toJson()).toList())
          .select();
      
      return response.map<NotificationModel>((json) => NotificationModel.fromJson(json)).toList();
    } catch (e) {
      rethrow;
    }
  }
}

@riverpod
NotificationRepository notificationRepository(NotificationRepositoryRef ref) {
  final client = ref.read(supabaseClientProvider);
  return NotificationRepository(client);
} 